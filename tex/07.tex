\section{Массивы и коллекции}


\subsection{Одномерные массивы}

\task Написать программу, выполняющую вейвлет-преобразование Хаара для
заданного массива с длиной, равной степени $2$. Само преобразование
выполняется следующим образом. В первую половину массива записываются
полусуммы пар соседних элементов, а во вторую — полуразности. После
этого преобразование повторяется для первой половины массива до тех
пор, пока не останется только одна полусумма.

Например, для массива $(2, 8, 6, 0)$ после первого шага получим
\[
\left(\frac{2+8}2, \frac{6+0}2, \frac{2-8}2, \frac{6-0}2\right) = (5, 3, -3, 3).
\]
На втором шаге преобразование будет применено только к полусуммам —
$(5, 3)$. В итоге получим массив
\[
\left(\frac{5+3}2, \frac{5-3}2, -3, 3\right) = (4, 1, -3, 3).
\]
Так как осталась одна полусумма, это и есть ответ.

\task Написать программу, случайным образом перемешивающую элементы
массива при помощи алгоритма Фишера — Йетса.

Идея метода следующая. На первом шаге первый элемент обменивается со
случайно выбранным элементом из массива (им может оказаться и сам
первый элемент). На втором шаге второй элемент обменивается со
случайно выбранным элементом кроме первого. На третьем — третий
элемент со случайным кроме первых двух и так далее. Операция
повторяется для каждого элемента массива.

\task Написать программу, заменяющую все составные числа в массиве
последовательных чисел от $2$ до указанного числа нулями при помощи
алгоритма, называемого решетом Эратосфена. Идея алгоритма следующая:
перебираются все элементы, если элемент не нулевой, то заменяютя
нулями все, идущие после него с шагом, равным значению этого
элемента. Алгоритм продолжается до элемента со значением
$\left\lceil\sqrt N\right\rceil,$ где $N$ — значение последнего
элемента.

Например, для массива $(2, 3, 4, 5, 6, 7, 8, 9)$ последовательность
преобразований имеет вид (текущий элемент подчёркнут):
\begin{eqnarray*}
&(\underline2, 3, \cancel4, 5, \cancel6, 7, \cancel8, 9),\\
&(2, \underline3, 0, 5, \cancel0, 7, 0, \cancel9),\\
&(2, 3, \underline0, 5, 0, 7, 0, 0).
\end{eqnarray*}

\task Написать программу для так называемой «пузырьковой сортировки»
массива по неубыванию. Идея метода следующая. Просматриваются все пары
соседних элементов и, если их порядок неверный, они обмениваются
местами. Проходы по массиву повторяются, пока не окажется, что массив
отсортирован.

\task Написать программу для сортировки массива по неубыванию простым
выбором. Идея метода следующая. В массиве ищется наименьший элемент и
меняется местами с первым, затем наименьший среди оставшихся меняется
местами со вторым и так далее.

\task Написать программу, переставляющую элементы массива так, чтобы
сначала были записаны значения, меньшие некоторого числа $p$, потом
равные ему, а затем остальные.

\task Написать программу, реализующую так называемое правило~30 для
клеточных автоматов. Дан массив заданной длины, элементы которого
равны нулю кроме среднего, который равен единицы. Программа должна
выполнить указанное число шагов преобразований массива выводя на
каждом шаге результат.

В ходе преобразования проверяются все ячейки массива, кроме
крайних. На следующем шаге ячейка становится равной $1$ тогда и только
тогда, когда она со своими соседями образует одну из четырёх
комбинаций: $100$, $010$, $001$ или $011$. В противном случае ячейка
на новом шаге будет равна $0$.

Например для массива размера $7$ первые три шага имеют вид:
\begin{eqnarray*}
&0001000,\\
&0011100,\\
&0110010.
\end{eqnarray*}

\task Написать программу, разбивающую массив на три подмассива с
сохранением порядка. При этом суммы элементов в них должны быть как
можно ближе друг к другу: разница между наибольшей и наименьшей
суммами должна быть минимальной. Программа должны вывести номера
первых элементов второго и третьего подмассивов.

Например, массив $(1, 2, 3, 2, 2)$ разбивается на подмассивы $(1, 2)$,
$(3)$ и $(2, 2).$ Если элементы нумеруются с нуля, то искомые индексы
— 2 и 3.

\task Написать программу, находящую максимальное значение, которое
можно получить, складывая последовательные элементы массива. Например,
для массива $(1, -2, 3, 1, -1, 2)$ максимальная сумма равна
$3+1+(-1)+2=5$.

\task Написать программу для тернарного поиска элемента в
отсортированном массиве. Алгоритм похож на бинарный поиск. Массив
делится двумя точками на три части приблизительно равного
размера. Затем сравнивая искомое значение со значениями в точках,
определяем, в какой из частей оно находится. Затем поиск повторяется в
этой части, и так далее, пока не будет найден элемент или не окажется,
что его нет в массиве.


\subsection{Многомерные массивы}

\task Дан двумерный массив целых чисел. Заменить нулями элементы,
стоящие в строках и столбцах, в которых есть нулевые элементы.

\task Дан двумерный массив действительных чисел. Заменить каждый элемент
арифметическим средним его смежных соседей по горизонтали, вертикали и
диагонали.

\task Дан двумерный массив размера $M\times N$ действительных
чисел. Нормировать его по формуле
\[
a_{ij}^\textrm{норм} = \frac{a_{ij}-\bar{a}}{\sigma},
\]
где $\bar{a}$ — математическое ожидание, а $\sigma$ — стандартное
отклонение, вычисляемые по формулам
\begin{align*}
  \bar{a} &= \frac{1}{MN}\sum_{i,j}a_{ij},\\
  \sigma  &= \sqrt{\frac{1}{MN}\sum_{i,j}(a_{ij}-\bar{a})^2}. 
\end{align*}

\task Дан двумерный массив действительных чисел. Проверить, есть ли в
нём линейно зависимые строки и столбцы.

\task Заполнить двумерный массив указанного размера последовательными
натуральными числами двигаясь от верхнего левого элемента вправо и
далее по спирали.

Пример заполнения для массива $3\times 3$:
\[
\begin{array}{ccc}
  1 & 2 & 3 \\
  8 & 9 & 4 \\
  7 & 6 & 5
\end{array}
\]

\task Дан двумерный массив целых чисел. Проверить, сколько в нём
квадратов размера $2\times 2$, состоящих только из чётных элементов.

\task Дан квадратный массив действительных чисел. Сформировать массив
с суммами элементов на его диагоналях.

\task Даны две двумерные матрицы. Найти их произведение, если это
возможно.

\task Дан двумерный массив вещественных чисел. Заменить каждый его
элемент арифметическим средним элементов ниже и правее него.

\task Дан двумерный массив. Записать его элементы в одномерный массив
по строкам. При этом нечётные строки обходятся слева направо, а чётные
справа налево.

\subsection{Коллекции и их применение}

\task Дана последовательность, содержащая шесть видов скобок: (, ), [,
], \{, \}. Написать программу, проверяющую, является ли скобочная
запись, задаваемая последовательностью, корректной. Иными словами,
программа должна проверить правильность вложенности пар скобок,
отсутствие «незакрытых» и лишних «закрывающих» скобок.

Например, последовательность «([]\{\})» корректна, а «)[\{]\}» нет.

\task Дана закодированная последовательность чисел. Написать
декодирующую программу, работающую по следующему алгоритму. Если
очередное число $x$ положительное, то оно копируется в декодированную
последовательность, если отрицательное, то копируется $|x|$ последних
значений из декодированного потока.

Например, последовательность $(1, 2, 3, -2, -3)$ будет декодирована как
$(1, 2, 3, 2, 3, 3, 2, 3).$

\task Написать программу, заменяющую каждый элемент последовательности
чисел на индекс его первого вхождения.

\task Написать программу, проверяющую, верно ли, что количество
повторов какого-либо элемента последовательности равно его значению.

Например, последовательность $(4, 2, 4, 2, 4, 1, 4)$ удовлетворяет
этому условию.

\task Написать программу, которая каждый элемент последовательности
повторяет столько раз, сколько он встречался до этого.

Например, последовательность
\[
(1, 2, 1, 2, 1)
\]
будет преобразована в 
\[
(1, 2, 1, 1, 2, 2, 1, 1, 1).
\]

\task Дано клетчатое поле размера $N\times N,$ заполненное единицами и
нулями. В первой строке и первом столбце находится фигура, которая
может ходить только по вертикали или горизонтали и только на клетки, в
которых находится единица. Написать программу, определяющую сколько
клеток может посетить фигура.

Подсказка: используйте очередь для хранения координат клеток, которые
нужно проверить на возможность посещения.

Например, на поле
\[
\begin{array}{ccc}
  1 & 0 & 1 \\
  1 & 0 & 1 \\
  1 & 1 & 0
\end{array}
\]
фигура сможет посетить 4 клетки.

\task Рассмотрим приём ускорения вычислений, называемый
мемоизацией. Требуется написать функцию Apply, принимающую некоторую
функцию $f$ и число $x$. Функция $f$ принимает и возвращает
действительное число. Функция Apply должна вычислить $f(x)$ и вернуть
результат. Для ускорения расчётов все уже вычисленные значения
помещаются в словарь. Если требуется найти $f(x),$ которое уже было
посчитано ранее, функция $f$ не вызывается, а используется значение из
словаря.

Написать программу, использующую функцию Apply.

\task Рассмотрим изменённый вариант задачи Иосифа Флавия. Числа от
одного до некоторого $N$ записаны по кругу. Затем каждое $k$-е
(начиная с единицы) число вычёркивается, как в считалке с
выбыванием. Процесс продолжается, пока не останется одно
число. Написать программу, выводящую на экран последовательность
вычеркивания чисел.

Например, если $N=5,$ а $k=3$, то последовательность будет иметь вид
\[
(3, 1, 5, 2, 4).
\]

\task Даны два стека целых чисел. В первом содержатся некоторые
целочисленные значения (данные), а во втором коды команд. Команды
управляют процессом вычислений и могут быть одного из следующих видов:
\begin{itemize}
\item $1$ — взять два значения из первого стека и положить обратно
  сумму;
\item $2$ — взять два значения из первого стека и положить обратно
  разность (верхушка — уменьшаемое);
\item $3$ — поменять местами два верхних значения первого стека;
\item $4$ — скопировать значение из второго стека в первый.
\end{itemize}
Перед выполнением команды извлекаются из второго стека. Если код
команды отличается от перечисленных, она игнорируется.

Написать программу, выполняющую команды второго стека и затем
выводящую на экран верхушку первого. Если какую-то команду выполнить
невозможно — вывести на экран сообщение об ошибке.

Например, если стек данных имел вид $(3, 2, 1),$ а стек команд —
$(1, 2)$ (верхушка слева), то результатом работы программы будет число
$4$.

\task Написать программу, реализующую следующий алгоритм слияния двух
отсортированных последовательностей. Новая последовательность
формируется при помощи многократного выбора из концов заданных
исходных наименьшего элемента.


\subsection{LINQ}

\task В некоторой коллекции хранятся радиусы окружностей. Написать
LINQ-выражение, выбирающее только те радиусы, для которых площади
окружностей больше либо равны 4.

\task В некоторой коллекции хранятся значения углов в
градусах. Написать LINQ-выражение, выбирающее только острые углы.

\task В некоторой коллекции хранятся целые числа. Написать
LINQ-выражение, формирующее коллекцию их квадратов.

\task В некоторой коллекции хранятся углы в радианах. Написать
LINQ-выражение, выбирающее только те углы, косинусы которых
неотрицательны.

\task В некоторой коллекции хранятся целые числа. Написать
LINQ-выражение, выбирающее только положительные двузначные числа.

\task В некоторой коллекции хранятся целые числа. Написать
LINQ-выражение, выбирающее только чётные числа.

\task В некоторой коллекции хранятся вещественные числа. Написать
LINQ-выражение, формирующее коллекцию с их целыми частями.

\task В некоторой коллекции хранятся целые числа. Написать
LINQ-выражение, выбирающее только числа, заканчивающиеся на 7.

\task В некоторой коллекции хранятся целые числа. Написать
LINQ-выражение, выбирающее только числа, делящиеся на 11.

\task В некоторой коллекции хранятся целые числа. Написать
LINQ-выражение, формирующее коллекцию, содержащую их последние цифры.
