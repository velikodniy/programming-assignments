\section{Обобщённые классы}

\subsection{Обобщённые структуры данных}

\task Написать обобщённый класс \Lst{QuadTree}, реализующий
квадродерево — дерево, у каждого внутреннего узла которого ровно 4
потомка. Значения в узлах могут быть произвольного типа.

Каждый узел дерева должен хранить пару значений $(x,y)$. Ссылки на
потомков называются \Lst{LT}, \Lst{LB}, \Lst{RT}, \Lst{RB}. При этом
заполнение осуществляется следующим образом. Если добавляется пара
$(x, y)$, а текущий узел — $(x^*,y^*),$ то элемент будет добавлен в
поддерево в соответствии с таблицей \ref{table:QuadTree}.

\begin{table}[b]
  \centering
  \begin{tabular}{c|cc}
      & L   &R\\
    \hline
    T & $x \leqslant x^*, y > y^*$         & $x > x^*, y > y^*$\\
    B & $x \leqslant x^*, y \leqslant y^*$ & $x > x^*, y \leqslant y^*$
  \end{tabular}
\caption{Свойства ветвей квадродерева}\label{table:QuadTree}
\end{table}

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Add} — добавить узел с указанным значением в дерево в
  качестве нового листа,
\item \Lst{Exists} — проверить, содержит ли дерево узел с указанным
  значением.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{CircularLinkedList}, реализующий
кольцевой связный список, хранящий элементы произвольного
типа. 

Кольцевой связный список — это разновидность односвязного списка, у
которого последний элемент содержит ссылку на первый. Экземпляр класса
должен содержать ссылку на текущий элемент списка.

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Add} — добавить элемент в список после текущего,
\item \Lst{Shift} — переместить ссылку на следующий элемент,
\item \Lst{Remove} — вернуть текущий элемент и удалить его из списка.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{Heap}, соответствующий пирамиде,
хранящей элементы произвольного типа. (Эта структура данных также
называется кучей.)

Пирамида представляет собой бинарное дерево, элементы которого
располагаются в массиве размера $2^d-1,$ где $d$ — высота
дерева. Связи между элементами явно не хранятся. Все элементы
пронумерованы послойно, как показано на рисунке \ref{fig:heap}.

\begin{figure}
  \centering
  \begin{tikzpicture}[level distance=1cm,
    level 1/.style={sibling distance=2cm},
    level 2/.style={sibling distance=1cm}]
    \node {0}
      child {node {1}
        child {node {3}}
        child {node {4}}
      }
      child {node {2}
        child {node {5}}
        child {node {6}}
      };
  \end{tikzpicture}

  \caption{Соответствие номеров элементов пирамиды и массива\label{fig:heap}}
\end{figure}

Как видно из рисунка, левый потомок узла $k$ будет иметь номер $2k+1$,
а правый — $2k+2.$ Поэтому явное указание связей между узлами не требуется.

Изначально элементы массива равны нулевой ссылке и считаются
пустыми. Элементы добавляются так же, как и в бинарном дереве поиска.

Высота дерева должна задаваться в конструкторе.

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Add} — добавить элемент с указанным значением в пирамиду,
\item \Lst{Exists} — проверить, содержит ли пирамида элемент с указанным
  значением.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{PriorityStack}, реализующий
стек с приоритетом, хранящий значения произвольного типа. Вместе со
значением элементы стека должны хранить приоритет — некоторое целое
число.

Стек с приоритетом реализуется на основе односвязного списка. 

При добавлении элемент помещается в такую позицию списка, чтобы
приоритеты были упорядочены по возрастанию. На верхушке стека после
добавления всегда должен быть элемент с наибольшим приоритетом.

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Push} — добавить значение с указанным приоритетом в стек,
\item \Lst{Pop} — возвращает элемент с наибольшим приоритетом.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{TernaryTree}, реализующий
тернарное дерево — дерево, у каждого внутреннего узла которого три
потомка. Значения в узлах могут быть произвольного типа. Для каждого
узла дерева со значением $x$ должны выполняться свойства: значения
узлов левого поддерева меньше, среднего — равны, а правого — больше
$x$.

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Add} — добавить узел с указанным значением в дерево в
  качестве нового листа,
\item \Lst{Exists} — проверить, содержит ли дерево узел с указанным
  значением.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{UnrolledList}, реализующий
развёрнутый список — односвязный список, содержащий не отдельный
значения, а массивы. Размер каждого массива — N (задаётся в
конструкторе). При добавлении элемента сперва заполняется первый
массив, затем создаётся новый и заполняется он. При этом элемент,
хранящий первый массив, ссылается на элемент, хранящий второй.

Класс должен хранить количество заполненный элементов последнего
массива, чтобы знать, где заканчивается список.

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Add} — добавить новый элемент в конец списка,
\item \Lst{Get} — получить элемент списка по номеру.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{PriorityQueue}, реализующий
очередь с приоритетом, хранящую значения произвольного типа. Вместе со
значением элементы очереди должны хранить приоритет — некоторое целое
число.

Очередь с приоритетом реализуется на основе двусвязного списка. В нём
каждый элемент содержит ссылку как на следующий, так и на предыдущий
элементы. Экземпляр класса должен содержать ссылки на первый и
последний элементы списка.

При добавлении элемент помещается в такую позицию очереди, чтобы
приоритеты были упорядочены по возрастанию. В начале очереди будет
наименьший приоритет, а в конце — наибольший.

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Enqueue} — добавить значение с указанным приоритетом в очередь,
\item \Lst{Dequeue} — возвращает элемент с наибольшим приоритетом.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{LinkedList2}, реализующий
односвязный список, в котором элементы дополнительно содержат ссылку
на следующий через один элемент (как показано на рисунке
\ref{fig:list2}).  Значения элементов могут быть произвольного типа.

\begin{figure}
  \centering
  \tikzstyle{line} = [draw, -latex']
  \usetikzlibrary{shapes,positioning,shapes.misc,fit}
  \begin{tikzpicture}[
      thick,
      node distance=1.5cm,
      text height=1.2ex,
      text depth=.1ex,
      auto]

      \tikzset{
        null box/.style={
          rectangle,
          draw=black,
          append after command={
            [every edge/.append style={
              thick,
              shorten >=\pgflinewidth,
              shorten <=\pgflinewidth,
            }]
            (\tikzlastnode.north west) edge (\tikzlastnode.south east)
            (\tikzlastnode.north east) edge (\tikzlastnode.south west)
          }
        }
      }

      \node[draw]                         (A)  {A};
      \node[right of=A, draw]             (B)  {B};
      \node[right of=B, draw]             (C)  {C};
      \node[right of=C, draw]             (D)  {D};
      \node[right of=D, null box]  (X)  { };
    
      \path[line] (A) edge (B);
      \path[line] (B) edge (C);
      \path[line] (C) edge (D);
      \path[line] (D) edge (X);

      \path[line] (A) edge[out= 45, in= 135] (C);
      \path[line] (B) edge[out= -45, in= -135] (D);
      \path[line] (C) edge[out= 45, in= 135] (X);
      \path[line] (D) edge[out= -45, in= -135] (X);
  \end{tikzpicture}

  \caption{Односвязный список с дополнительной ссылкой\label{fig:list2}}
\end{figure}

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Add} — добавить элемент в начало списка,
\item \Lst{Get} — вернуть значение элемента по его номеру (при поиске
  перемещение выполнять через один элемент при возможности).
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{SearchTree}, реализующий бинарное
дерево поиска с узлами, хранящими значения произвольного типа.

Каждый узел должен хранить ссылку на родительский узел (для корня —
нулевую ссылку).

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Add} — добавить элемент в дерево,
\item \Lst{ListFrom} — найти узел с указанным значением и вернуть
  строку со списком значений узлов ветви от корня до найденного узла.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.

\task Написать обобщённый класс \Lst{OrderedList}, реализующий
односвязный список, в котором элементы дополнительно содержат ссылку на
следующий по величине элемент (то есть, минимальный среди элементов,
больших либо равных добавляемому). Значения элементов могут быть
произвольного типа.

Класс должен содержать методы:
\begin{itemize}
\item \Lst{Add} — добавить элемент в начало списка,
\item \Lst{ListFrom} — вернуть строку со списком элементов списка,
  больших либо равных, чем элемент с указанным номером.
\end{itemize}

Класс разместить в отдельной библиотеке. Написать программу,
использующую его.
